% You should title the file with a .tex extension (hw1.tex, for example)
%sudo apt-get install texstudio texlive-latex-extra

\documentclass[a4paper, 11pt]{article}
\usepackage{fancyvrb}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{graphicx}

\usepackage[margin=1in]{geometry}
\usepackage{tikz}
\usetikzlibrary{automata,positioning,arrows}

\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\newcommand{\question}[2] {\vspace{.25in} \hrule\vspace{0.5em}
	\noindent{\bf #1: #2} \vspace{0.5em}
	\hrule \vspace{.10in}}
\renewcommand{\part}[1] {\vspace{.10in} {\bf (#1)}}

\newcommand{\myname}{Possawat Sanorkam}
\newcommand{\myemail}{possawat2017@hotmail.com}
\newcommand{\myhwnum}{6}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}

\pagestyle{fancyplain}
\lhead{\fancyplain{}{\textbf{HW\myhwnum}}}      % Note the different brackets!
\rhead{\fancyplain{}{\myname\\ \myemail}}
\chead{\fancyplain{}{ICCS310}}

\begin{document}
	
	\medskip                        % Skip a "medium" amount of space
	% (latex determines what medium is)
	% Also try: \bigskip, \littleskip
	
	\thispagestyle{plain}
	\begin{center}                  % Center the following lines
		{\Large ICCS310: Assignment \myhwnum} \\
		\myname \\
		\myemail \\
		\today \\
	\end{center}
	
	\question{1}{The Meaning of Things} %don't delete yet:(}
	
	\part{1} Class NP is the problems that can be verify within polynomial time. Basically, there is no efficient algorithm to solve the problem. But, we can verify it pretty quick.
	
	\part{2} Without loss of generality, we can assume that there is a certificate and a verifier that check the certificate to verify whether it is a "yes" or "no" given that the verifier answer within polynomial time.
	
	\part{3} NP-complete is the problem that can only be solved within polynomial time using a NFA. Besides, we can solve it in polynomial time using a machine that compute all possibilities at once.
	
	\part{4} We can find a problem that is NP, then we find a polynomial time algorithm to change the solution from one problem to the problem that we want to show that it is NP-complete.
		
	\question{2}{Closure of NP} %don't delete yet:(}
	
	
	\part{i} Prove that $A \cap B$ must be in $\textsf{NP}$
	
	{\em Proof}: 
	
	We want to show that $A \cap B$ must be in $\textsf{NP}$. Given that $A \in \textsf{NP} $ and $B \in \textsf{NP}$, then we have $M_A$ and $M_B$ which are nondeterministic poly-time deciders for $A$ and $B$. $M_A$ runs in nondeterministic time $O(n^k)$ and $M_B$ runs in nondeterministic time $O(n^l)$ We want to show that there is a nondeterministic poly-time decider $M$ such that $L(M) = A \cap B$. 
	
	The construction of $M$ is as follow :
	
	Given $\langle w \rangle$ as input:
	
	1. Run $M_A$ on $w$. If $M_A$ rejects, then we reject.
	
	2. Else run $M_B$ on $w$. If $M_B$ rejects, then we reject.
	
	3. Else accept.
	
	From observation, the longest branch in any computation tree on input w of length n is $O(n^{max\{k,l\}})$. So, $M$ is poly-time nondeterministic decider for $A \cap B$.
	
	Therefore, $A \cap B$ must be in $\textsf{NP}$.
	 $\square$
	
	\part{ii} Prove that $A \cup B$ must be in $\textsf{NP}$
	
	{\em Proof}: 
	
	We want to show that $A \cup B$ must be in $\textsf{NP}$. Given that $A \in \textsf{NP} $ and $B \in \textsf{NP}$, then we have $M_A$ and $M_B$ which are nondeterministic poly-time deciders for $A$ and $B$. $M_A$ runs in nondeterministic time $O(n^k)$ and $M_B$ runs in nondeterministic time $O(n^l)$ We want to show that there is a nondeterministic poly-time decider $M$ such that $L(M) = A \cup B$. 
	
	The construction of $M$ is as follow :
	
	Given $\langle w \rangle$ as input:
	
	1. Run $M_A$ on $w$. If $M_A$ accepted, then we accept.
	
	2. Else run $M_B$ on $w$. If $M_B$ accepted, then we accept.
	
	3. Else reject.
	
	From observation, the longest branch in any computation tree on input w of length n is $O(n^{max\{k,l\}})$. So, $M$ is poly-time nondeterministic decider for $A \cap B$.
	
	Therefore, $A \cup B$ must be in $\textsf{NP}$.
	$\square$
	
	\question{3}{This is NP}
	
	Prove that $\textsf{5COLOR} \in \textsf{NP}$
	
	{\em Proof}: 
	
	We want to show that $\textsf{5COLOR} \in \textsf{NP}$. So, we want to claim that there exist a polynomially-bounded certificate and a polynomially-bounded verifier.
	
	Claim: There exists such polynomially-bounded certificate.
	
	We claim that the certificate that is a yes instance is the list of vertices describing the color in which we colored them. The length of such a certificate is the same as the number of vertices given. So, we got the certificate.
	
	Claim: There exists such polynomially-bounded verifier.
	
	We claim that the verifier that verify the certificate will check through the list of vertices describing the color in which we colored them. If there exists an edge that contain same color on both ends, we have that the certificate is a "no" instance. Otherwise, it is a "yes" instance. The time complexity of this algorithm is $O(|E|)$ where $E$ is the list of edges. So, we got the verifier.
	
	Hence, we showed that there exist a polynomially-bounded certificate and a polynomially-bounded verifier. Therefore, $\textsf{5COLOR} \in \textsf{NP}$.
		
	\question{4}{NP-Complete}
	
	\part{1} Prove that $\texttt{HAM-PATH}$ is NP-complete by showing a reduction $\texttt{HAM-CYCLE} \leq_m \texttt{HAM-PATH}$.

	{\em Proof}:  We want to show that $\texttt{HAM-PATH}$ is NP-complete. So, there exist a polynomially-bounded reduction from $\texttt{HAM-PATH}$ to $\texttt{HAM-CYCLE}$. 
	
	Let $G$ be the directed graph from $\texttt{HAM-CYCLE}$. We solve $\texttt{HAM-PATH}$ given $G$ by trying all possibilities and verify whether $G$ is an acceptable certificate by simply perform DFS and check if we can find the a path starting at s and ending at t that visits each and every vertex exactly once. We have $G^\prime$ from $\texttt{HAM-PATH}$ which is a graph with denoted order that would be a path starting at s and ending at t that visits each and every vertex exactly once if we do the DFS. So, we can convert $G^\prime$ back to $\texttt{HAM-CYCLE}$. Basically, we get $G^{\prime \prime}$ by simply perform a DFS on $G^\prime$ starting from s and label each node by the traversal order, then we have that $\texttt{HAM-CYCLE}$ can be solved from $G^{\prime \prime}$.
	
	This reduction takes $O(|V|+|E|)$ where $V$ is the vertices and $E$ is the edges of $G$.
	
	Hence, $\texttt{HAM-CYCLE} \leq_m \texttt{HAM-PATH}$. Therefore, $\texttt{HAM-PATH}$ is NP-complete. $\square$

	
	\part{2} Prove that $\texttt{UNDIRECTED-HAM-PATH}$ is NP-complete by showing a reduction $\texttt{HAM-PATH} \leq_m \texttt{UNDIRECTED-HAM-PATH}$.
	
	
	{\em Proof}: We want to show that $\texttt{UNDIRECTED-HAM-PATH}$ is NP-complete. So, there exist a polynomially-bounded reduction from $\texttt{HAM-PATH}$ to $\texttt{UNDIRECTED-HAM-PATH}$. 
	
	Let $G$ be the directed graph from $\texttt{HAM-PATH}$. We solve $\texttt{UNDIRECTED-HAM-PATH}$ given $G$ by first listing all the directed edges from $G$ and recreate a new undirected graph $G^\prime$ out of $g$ by duplicating each vertex into three vertices, first vertex represent the node that is directed to, second vertex is the vertex that direct edged to some vertices, and third vertex will help with redirecting the edges later, then we build it according to the edges from $G$. Then, trying all possibilities and verify whether $G$ is an acceptable certificate by simply perform DFS and check if we can find the a path starting at s and ending at t that visits each and every vertex exactly once. We have $G^\prime$ from $\texttt{UNDIRECTED-HAM-PATH}$ which is a graph with denoted order that would be a path starting at s and ending at t that visits each and every vertex exactly once if we do the DFS. So, we can convert $G^\prime$ back to $\texttt{HAM-PATH}$. Basically, we get $G^{\prime \prime}$ by simply combine the separated vertices into one node and recreate an undirected graph from the edges from $G^\prime$. Then, run a DFS on $G^\prime$ starting from s, label each edge by the traversal order, then we have that $\texttt{HAM-PATH}$ can be solved from $G^{\prime \prime}$.
	
	This reduction takes $O(|V|+|E|)$ where $V$ is the vertices and $E$ is the edges of $G$.
	
	Therefore, $\texttt{HAM-PATH} \leq_m \texttt{UNDIRECTED-HAM-PATH}$. $\square$
	
	\question{5}{Silver Lining If P = NP}
	
	Prove that if $\textsf{P} = \textsf{NP}$, then $\textsf{SPC} \in \textsf{P}$
	
	{\em Proof}: 
	
	Suppose that $\textsf{P} = \textsf{NP}$, then $\textsf{NP} = \textsf{coNP}$. Let $\overline{\textsf{SPC}}$ be a problem to check whether C is not the smallest-possible circuit with the exact same behavior as C. We want to show that $\overline{\textsf{SPC}}= \textsf{coNP}$.
	
	We want to show that $\overline{\textsf{SPC}}= \textsf{coNP}$. So, we want to claim that there exist a polynomially-bounded certificate and a polynomially-bounded verifier.
	
	Claim: There exists such polynomially-bounded certificate.
	
	We claim that the certificate that is a "yes" instance is the circuit smaller gates than C and input values. The length of such a certificate is the less than the number of gates in C. So, we got the certificate.
	
	Claim: There exists such polynomially-bounded verifier.
	
	We claim that the verifier that verify the certificate will run the circuit. If the  output is the same to C, it is "yes" instance. Otherwise, it is a "no" instance. The time complexity of this algorithm is $O(n)$ where $n$ is the size of input values. So, we got the verifier.
	
	Hence, we showed that there exist a polynomially-bounded certificate and a polynomially-bounded verifier. Therefore, $\overline{\textsf{SPC}}= \textsf{coNP}$.
	
	Hence, if $\overline{\textsf{SPC}}= \textsf{coNP}$, then $\textsf{SPC}= \textsf{NP}$ because $\textsf{P} = \textsf{NP}$ and $\textsf{P} = \textsf{coNP}$. 
	
	Therefore, if $\textsf{P} = \textsf{NP}$, then $\textsf{SPC} \in \textsf{P}$. $\square$
	
	\question{6}{ Longest-probe Bound For Hashing}
	
	At some point, we have to extend the hash table.
	
	\question{7}{ Prime Density}
	
	Too difficult.
	
\end{document}